{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#materialy","title":"Materi\u00e1ly","text":"<ul> <li>AG1 courses</li> <li>FIT Wiki</li> <li>Online FIT</li> </ul>"},{"location":"#contributors","title":"Contributors","text":""},{"location":"#truepeak-et-al","title":"Truepeak et. al","text":""},{"location":"00_Testy/DP_%C3%BAlohy/","title":"DP \u00falohy","text":"<p>Pozn\u00e1mka k rie\u0161eniam</p> <p>Rie\u0161enia s\u00fa work in progress, mali by by\u0165 spr\u00e1vne (v\u00e4\u010d\u0161ina je otestovan\u00e1 v pythone), pokia\u013e sa v\u00e1m nie\u010do nezd\u00e1, m\u00f4\u017eete da\u0165 vedie\u0165. Chcel som ich sem ale da\u0165, aby aj skor\u0161ie term\u00edny mali aspo\u0148 nejak\u00e9 my\u0161lienky, ako \u00falohy rie\u0161i\u0165.</p> <p>Nejdel\u0161\u00ed cesta v matici</p> <p></p> <p>Kuchy\u0148sk\u00e1 prk\u00fdnka</p> <p></p> <p>P\u0159evoz piva</p> <p></p> <p>P\u0159evleky oble\u010den\u00ed</p> <p></p> <p>Kabely</p>"},{"location":"00_Testy/DP_%C3%BAlohy/#implication-dp.1","title":"Nejdel\u0161\u00ed cesta v matici","text":"<ul> <li>Na vstupu je NxN matice Mat, kde ka\u017ed\u00fd prvek m\u00e1 ur\u010denou hodnotu. Prvky \\(Mat[0][0]\\) a \\(Mat[N-1][N-1]\\) maj\u00ed hodnotu 0. Zbytek n\u00e1hodn\u00e9 celo\u010d\u00edseln\u00e9 hodoty (z\u00e1porn\u00e9, nulov\u00e9 i kladn\u00e9).</li> <li>Navrhn\u011bte algoritmus, kter\u00fd nalezne posloupnost prvk\u016f za\u010d\u00ednaj\u00edc\u00ed na \\(Mat[0][0]\\) a kon\u010d\u00edc\u00ed na \\(Mat[N][N]\\), kde jejich sou\u010det je nejv\u011bt\u0161\u00ed. Nap\u0159\u00ed\u010d matic\u00ed se d\u00e1 pohybovat pouze sm\u011brem doprava (\\(Mat[i][j+1]\\)) a nebo dol\u016f (\\(Mat[i+1][j]\\)).</li> </ul> \u0158e\u0161en\u00ed <p>Ak sa nach\u00e1dzame na \u013eubovo\u013enom pol\u00ed\u010dku \\(x, y\\), vieme, \u017ee cesta s najv\u00e4\u010d\u0161\u00edm s\u00fa\u010dtom z tohto pol\u00ed\u010dka bu\u010f mus\u00ed pokra\u010dova\u0165 o pol\u00ed\u010dko doprava (\\(Mat[y][x + 1]\\)), alebo o pol\u00ed\u010dko dole (\\(Mat[y + 1][x]\\)). Jedna z t\u00fdchto ciest m\u00f4\u017ee ma\u0165 v\u00e4\u010d\u0161\u00ed s\u00fa\u010det, vyberieme si teda t\u00fa. Celkov\u00fd s\u00fa\u010det hodn\u00f4t na ceste, ktor\u00e1 n\u00e1m takto vznikne, bude teda:</p> \\[h(x, y) = Mat[x][y] + max(h(x + 1, y), h(x, y + 1))\\] <p>Toto sa rekurz\u00edvne d\u00e1 pop\u00edsa\u0165 nasleduj\u00facim pseudok\u00f3dom: <pre><code>max_cesta(M,N,x,y): \n\n    if x+1 &gt; N-1 and y+1 &gt; N-1: # nem\u016f\u017eeme ani doprava ani dolu\n        return 0\n\n    if x + 1 &lt;= N-1:\n        down_path = max_cesta(M,N,x+1,y) + M[x][y]\n    else:\n        down_path = INT_MIN #musime ulo\u017eit n\u011bjakou hodnotu pro porovn\u00e1n\u00ed\n                            #i v p\u0159\u00edpad\u011b, \u017ee nem\u016f\u017eeme j\u00edt dolu\n\n    if y + 1 &lt;= N-1:\n        right_path = max_cesta(M,N,x,y+1) + M[x][y]\n    else:\n        right_path = INT_MIN #stejn\u011b zde\n\n    return max(down_path,right_path)\n</code></pre></p> <p>\u010casov\u00e1 slo\u017eitost takov\u00e9ho \u0159e\u0161en\u00ed bude exponenci\u00e1ln\u00ed, proto\u017ee v ka\u017ed\u00e9m pol\u00ed\u010dku m\u00e1me dv\u011b mo\u017enosti rozhodnut\u00ed.   Pro memoizaci sta\u010d\u00ed vytvo\u0159it 2D tabulku, do kter\u00e9 budeme ukl\u00e1dat maxim\u00e1ln\u00ed d\u00e9lky cest. memo[i][j] reprezentuje d\u00e9lku nejdel\u0161\u00ed cesty z [0][0] do [i][j]. K\u00f3d se zm\u011bn\u00ed pouze tak, \u017ee p\u0159id\u00e1me memoiza\u010dn\u00ed tabulku (memo), kter\u00e1 bude inicializov\u00e1na hodnotami -nekone\u010dno. Postupn\u011b od [0][0] projdeme tabulku sm\u011brem shora dol\u016f a zleva doprava. Pokud najdeme cestu do bu\u0148ky [i][j], jej\u00ed\u017e d\u00e9lka je v\u011bt\u0161\u00ed ne\u017e ji\u017e ulo\u017een\u00e1 hodnota v memo[i][j], nastav\u00edme hodnotu memo[i][j] na nov\u011b nalezenou hodnotu.  D\u016fkaz spr\u00e1vnosti by se dal prov\u00e1d\u011bt indukc\u00ed od lev\u00e9ho horn\u00edho pol\u00ed\u010dka memoiza\u010dn\u00ed tabulky. V\u00edme, \u017ee toto pole je vypln\u011bn\u00e9 spr\u00e1vn\u011b (m\u00e1 hodnotu 0). Pro jak\u00e9koli pole jinde v memoiza\u010dn\u00ed tabulce pot\u0159ebujeme, aby bylo vypln\u011bn\u00e9 pole nad n\u00edm nebo vlevo od n\u011bj, co\u017e u\u017e bu\u010f plat\u00ed, nebo se rekurzivn\u011b vypln\u00ed. Hodnotu v dan\u00e9m poli v memoiza\u010dn\u00ed tabulce potom vypo\u010d\u00edt\u00e1me jako max(M[x-1][y] + memo[x - 1][y], M[x][y-1] + memo[x][y - 1]), co\u017e ale bude nejv\u011bt\u0161\u00ed suma cesty od pol\u00ed\u010dka [0][0] do pol\u00ed\u010dka [N-1][N-1], d\u00edky tomu, \u017ee se do ka\u017ed\u00e9ho pol\u00ed\u010dka [x][y] m\u016f\u017eeme dostat poze z bun\u011bk [x-1][y] nebo [x][y - 1].</p> <pre><code>max_cesta(M,N):\n    memo := tabulka N x N naplnena -inf \n    for i = 0 .. N-1:\n        for j = 0 .. N-1:\n            if i == 0 and j == 0: \n                memo[i][j] = 0 # \"z\u00e1kladn\u00ed krok\" (M[0][0] je v\u017edy 0 dle zad\u00e1n\u00ed)                        \n            # \u00falo\u017e nejv\u011bt\u0161\u00ed hodnotu\n            if i + 1 &lt; N: \n                memo[i+1][j] = max(memo[i][j] + M[i][j], memo[i+1][j])\n            if j + 1 &lt; N: \n                memo[i][j+1] = max(memo[i][j] + M[i][j], memo[i][j+1])\n\n    return memo[N-1][N-1]\n</code></pre> <p> \u010casov\u00e1 slo\u017eitost tohoto \u0159e\u0161en\u00ed je \\(\\mathcal{O}(N^2)\\), proto\u017ee uvnit\u0159 cykl\u016f m\u00e1me v\u017edy konstantn\u00ed po\u010det krok\u016f. Prostorov\u00e1 slo\u017eitost je \\(\\mathcal{O}(N^2)\\)</p>"},{"location":"00_Testy/DP_%C3%BAlohy/#implication-dp.2","title":"Kuchy\u0148sk\u00e1 prk\u00fdnka","text":"\u0158e\u0161en\u00ed <p>Probl\u00e9m treba, ako skoro v\u017edy v DP, preformulova\u0165 na rozhodnutia, ktor\u00e9 m\u00f4\u017eeme v nejakom n-tom centimetri prkna spravi\u0165. Bu\u010f m\u00f4\u017eeme v n-tom centimetri za\u010da\u0165 reza\u0165 prkno, alebo m\u00f4\u017eeme tento centimeter vynecha\u0165, a pokra\u010dova\u0165 pozret\u00edm sa na \\(n + 1\\) centimeter. </p> <p> Ozna\u010dme si \\(T(n)\\) sumu, ktor\u00fa m\u00f4\u017eeme od n-t\u00e9ho centimetra z\u00edska\u0165. V pr\u00edpade, \u017ee v n-tom centimetri za\u010dneme reza\u0165, bude sa cena rovna\u0165:</p> \\[T(n) = K - P[n] - P[n + 1] - P[n+2] ... - P[n + D - 1] + T(n + D)\\] <p>teda cene jedn\u00e9ho prkienka, m\u00ednus ceny opr\u00e1v dan\u00fdch centimetrov, plus cena prkienok ktor\u00e9 vieme vytvori\u0165 od \\((n + D)\\)-t\u00e9ho centimetra. Ako v\u0161ak u\u017e bolo spomenut\u00e9, dan\u00fd centimeter m\u00f4\u017eeme aj vynecha\u0165, teda cena by bola \\(T(n) = T(n + 1)\\). Ke\u010f\u017ee m\u00e1me dve mo\u017enosti, budeme si op\u00e4\u0165 vybera\u0165 t\u00fa, ktor\u00e1 vedie k maxim\u00e1lnej cene:</p> <pre><code>rezanie(i):\n    if i + D &gt; N: return 0 \n    cena_rezanie = 0\n    if i + D &lt;= N: # mozeme rezat iba ak nam zostava &gt; D centimetrov\n        cena_rezanie = K - suma(P[i] ... P[i + D - 1]) + rezanie(i + D)\n    cena_skip = rezanie(i + 1)\n    return max(cena_rezanie, cena_skip)\n</code></pre> <p>Memoizovalo by sa do 1D pola, ktor\u00e9 by sme postupne nap\u013a\u0148ali maxim\u00e1lnou cenou, ktor\u00fa m\u00f4\u017eeme od i-t\u00e9ho centimetra z\u00edska\u0165. </p> <pre><code>memo = pole dlzky N naplnene undef\nrezanie(i):\n    if i + D &gt; N: return 0 \n    if memo[i] != undef: return memo[i]\n    cena_rezanie = 0\n    if i + D &lt;= N: \n        cena_rezanie = K - suma(P[i] ... P[i + D - 1]) + rezanie(i + D)\n    cena_skip = rezanie(i + 1)\n    memo[i] = max(cena_rezanie, cena_skip)\n    return memo[i]\n</code></pre> <p>V tomto pr\u00edpade je celkom intuit\u00edvne aj iterat\u00edvne rie\u0161enie. Pre i-t\u00fd prvok n\u00e1m toti\u017e sta\u010d\u00ed vedie\u0165 hodnoty \\(memo[i + 1]\\) a \\(memo [i + D]\\) (pokia\u013e je \\(i + D &lt;= N\\)). M\u00f4\u017eeme teda nap\u013a\u0148a\u0165 pole odzadu (po\u010d\u00edta\u0165 najlep\u0161ie miesta na rezanie odzadu, a potom ich sp\u00e1ja\u0165 dokopy, vpodstate tak ako pri NRP) <pre><code>rezanie():\n    memo = pole dlzky N+1 naplnene 0\n    for i = N - 1 ... 0\n        cena = 0\n        if i + 1 &lt; N: cena = memo[i + 1]\n        if i + D &lt;= N: \n            cena = max(cena, K - suma(P[i] ... P[i + D - 1]) + memo[i + D])\n        memo[i] = cena\n\n    return memo[0]\n</code></pre></p> <p>Vzh\u013eadom na to, \u017ee pri ka\u017edom poli v memoiza\u010dnej tabu\u013eke str\u00e1vime kon\u0161tantn\u00fd \u010das, bude zlo\u017eitos\u0165 z\u00e1le\u017ea\u0165 iba na ve\u013ekosti tabu\u013eky, teda \\(\\mathcal{O}(n)\\)</p>"},{"location":"00_Testy/DP_%C3%BAlohy/#implication-dp.3","title":"P\u0159evoz piva","text":"<p>Pepa p\u0159ev\u00e1\u017e\u00ed pivo ve m\u011bst\u011b. V\u0161echny domy jsou na jedn\u00e9 p\u0159\u00edmce. Ka\u017ed\u00fd d\u016fm m\u00e1 ozna\u010deno kolik si objednal piva a kde sa nach\u00e1dz\u00ed v jednoprvkov\u00e9 sou\u0159adnici. Voz\u00edk v\u00e1\u017e\u00ed ~ 20 piv, p\u0159i pohybu k domu se po\u010d\u00edt\u00e1 celkov\u00e1 \u00fanava podle: celkov\u00e1 v\u00e1ha \\(\\times\\) u\u0161l\u00e1 vzd\u00e1lenost. Ze startu (poz\u00edcia pivovaru je zadan\u00e1) m\u00e1 v\u017edy ve voz\u00edku v\u0161echny pot\u0159ebn\u00e1 piva (nemus\u00ed se tedy \u0159e\u0161it, \u017ee vezme prvn\u011b p\u00e1r piv a pak se bude vracet pro dal\u0161\u00ed). P\u0159i n\u00e1v\u0161t\u011bv\u011b domu vylo\u017e\u00ed v\u0161echna pot\u0159ebn\u00e1 piva. Je t\u0159eba naj\u00edt posloupnost n\u00e1v\u0161t\u011bv dom\u016f tak, aby celkov\u00e1 \u00fanava byla nejmen\u0161\u00ed. Pepa se z\u00e1rove\u0148 mus\u00ed vr\u00e1tit zp\u00e1tky do pivovaru.</p> Hint <p>V ka\u017edom momente sa sta\u010d\u00ed pozera\u0165 na najbli\u017e\u0161\u00ed prav\u00fd a \u013eav\u00fd dom.</p> \u0158e\u0161en\u00ed <p>D\u00f4le\u017eit\u00e9 je si uvedomi\u0165, \u017ee kedyko\u013evek prejdeme okolo domu, chceme vyhodi\u0165 piv\u00e1, ktor\u00e9 dan\u00fd dom chce (preto\u017ee na\u010do ich budeme \u010falej vl\u00e1\u010di\u0165, minieme len viac energie). Probl\u00e9m sa teda transformoval na bin\u00e1rne rozhodnutie. P\u00f4jdeme najprv do domu ktor\u00fd je n\u00e1m najbli\u017e\u0161ie na\u013eavo, alebo napravo? V danom dome piv\u00e1 vyhod\u00edme, a p\u00fdtame sa rovnak\u00fa ot\u00e1zku. </p> <p> Pre lep\u0161iu predstavu sem d\u00e1vam pseudok\u00f3d rekurz\u00edvneho rie\u0161enia, je to u\u017e ale dlh\u0161ie: <pre><code>H := pole pozicii domov # zoradene !!!\nC := pole po\u010dtu piv, ktore i-ty dom chce\n\nbeerstuff(closest_left, closest_right, our_position, weight):\n    # closest_left a closest_right su indexy domov, ktore su nam najblizsie vlavo a vpravo\n    # akonahle nejaky dom prejdeme, napriklad vlavo, mozeme dat closest_left--, a vpodstate sa tvarit, ze closest_left uz neexistuje.\n    # musime vsak pritom posunut our_position na H[closest_left]\n\n    if closest_left == -1 and closest_right == n: # presli sme vsetky domy\n        return (starting_position - our_position) * weight # musime sa vratit na start\n\n    left_cost = inf\n    # ak mozme ist dolava\n    if closest_left != -1: \n        left_cost = (our_position - H[closest_left]) * weight + beerstuff(closest_left - 1, closest_right, H[closest_left], weight - C[closest_left])\n\n    right_cost = inf\n    if closest_right != n: \n        right_cost = (H[closest_right] - our_position) * weight + beerstuff(closest_left, closest_right + 1, H[closest_right], weight - C[closest_right])\n\n    return min(left_cost, right_cost)\n\nfind_cheapest(starting_position):\n    left := find index of closest house to the left of starting_position\n    right := find index of closest house to the right of starting position\n    return beerstuff(left, right, starting_position, sum(C) + 20) # + 20 pre vahu vozika\n</code></pre></p> <p>Memoiz\u00e1cia by tu u\u017e bola trochu komplikovanej\u0161ia. Potrebovali by sme memoiza\u010dn\u00fa tabu\u013eku ve\u013ekosti \\(n \\times n \\times 2\\), pre v\u0161etky kombin\u00e1cie closest_left, closest_right a our_position. Pre our_position naozaj potrebujeme iba 2 pr\u00edpady, bu\u010f za\u010d\u00edname v closest_left alebo closest_right (rekurz\u00edvne volania bud\u00fa v\u017edy z poz\u00edcie nejak\u00e9ho domu, konkr\u00e9tne closest_left alebo closest_right, pozri pseudok\u00f3d). Pri vy\u0165ahovan\u00ed vzdialenosti z memoiza\u010dnej tabu\u013eky by sme potom potrebovali nie\u010do ako: <pre><code>if memo[closest_left][closest_right] != undef:\n    go_left_cost = weight * (our_position - H[closest_left]) + memo[closest_left][closest_right][LEFT] \n    go_right_cost = weight * (H[closest_right] - our_position) + memo[closest_left][closest_right][RIGHT]\n    return min(go_left_cost, go_right_cost)\n</code></pre></p> <p>Po\u010d\u00edtame teda ko\u013eko n\u00e1s stoj\u00ed dosta\u0165 sa do \u013eav\u00e9ho/prav\u00e9ho domu + ko\u013eko sa unav\u00edme odtia\u013e. Pre ka\u017ed\u00e9 pol\u00ed\u010dko v memoiza\u010dnej tabu\u013eke v\u0161ak st\u00e1le rob\u00edme iba kon\u0161tant\u00fd po\u010det oper\u00e1ci\u00ed, a tabu\u013eka je r\u00e1dovo ve\u013ekosti \\(n^2\\), dost\u00e1vame \u010dasov\u00fa zlo\u017eitos\u0165 \\(\\mathcal{O}(n^2)\\).</p>"},{"location":"00_Testy/DP_%C3%BAlohy/#implication-dp.4","title":"P\u0159evleky oble\u010den\u00ed","text":"<p>OCR Tohle fakt nep\u0159e\u010detlo</p> <p></p> \u0158e\u0161en\u00ed <p>Na konci na\u010drtnem aj my\u0161lienku vracanie priradenia prevlekov, niekedy to v zadan\u00ed chc\u00fa.</p> <p> Budeme postupova\u0165 podobne ako u prkien, len s dvoma polami. Najprv si zorad\u00edme policajtov a prevleky pod\u013ea ve\u013ekosti, od najmen\u0161\u00edch po najv\u00e4\u010d\u0161\u00edch. N\u00e1sledne budeme prech\u00e1dza\u0165 policajtov z\u013eava doprava, a bu\u010f im prevlek \\(q\\) prirad\u00edme, alebo nie. V pseudok\u00f3de asi takto: <pre><code>Policajti := pole velkosti policajtov, zoradene\nPrevleky := pole velkosti prevlekov, zoradene\n\nprirad_prevlek(p, q): # kde p je index policajta, q index prevleku\n    if p == Policajti.length: return 0\n    if q == Prevleky.length: return +inf # niekto nema prevlek\n\n    # ak nedame policajtovi p prevlek q, pozerame sa na q + 1.\n    napadnost_skip = prirad_prevlek(p, q + 1)\n\n    napadnost_noskip = prirad_prevlek(p + 1, q + 1) # dame policajtovi p prevlek q\n    if (Prevleky[q] &gt; Policajti[p]): napadnost_noskip += (Prevleky[q] - Policajti[p])\n    if (Prevleky[q] &lt; Policajti[p]): napadnost_noskip += (Policajti[p] - Prevleky[q])^2\n\n    return min(napadnost_noskip, napadnost_skip)\n</code></pre></p> <p>Mo\u017eno je tu d\u00f4le\u017eit\u00e9 vysvetli\u0165, pre\u010do m\u00f4\u017eeme prech\u00e1dza\u0165 polia z\u013eava doprava, a nemus\u00edme sk\u00fasi\u0165 ka\u017ed\u00fd policajt s ka\u017ed\u00fdm prevlekom. Intuit\u00edvne to akosi d\u00e1va zmysel, mysl\u00edm, \u017ee by tu sta\u010dil argument typu: Ak m\u00e1me nejak\u00e9ho policajta \\(V[i]\\), a nejak\u00fd prevlek \\(P[j]\\), tak bu\u010f plat\u00ed:</p> <ol> <li>\\(V[i] &gt; P[j]\\) - vieme z k\u00f3du, \u017ee m\u00e1me mo\u017enost preskakova\u0165 obleky. Povedzme, \u017ee existuje nejak\u00fd index \\(k\\), ke\u010f prv\u00fd kr\u00e1t od \u013eava je \\(V[i] &lt; P[k]\\). Od indexov \\(j\\) do \\(k\\) v\u0161ak mus\u00ed n\u00e1padnos\u0165 klesa\u0165 (bl\u00ed\u017eime sa k nulov\u00e9mu rozdielu). Od \\(j\\)-t\u00e9ho do \\(k\\)-t\u00e9ho indexu sa teda nach\u00e1dza najoptim\u00e1lnej\u0161\u00ed prevlek pre dan\u00e9ho policajta, a ten rekurz\u00edvnym sledom skipov aj vysk\u00fa\u0161ame.</li> <li>\\(V[j] &lt; P[j]\\) - na druhej strane, ak n\u00e1m nastane toto aj v pr\u00edpade ke\u010f sme \u017eiadne obleky nepresko\u010dili, vieme, \u017ee presko\u010den\u00edm obleku, teda dostan\u00edm sa na nejak\u00fd index \\(k &gt; j\\) len n\u00e1padnos\u0165 zv\u00fd\u0161ime. V k\u00f3de v\u0161ak sk\u00fasime aj mo\u017enos\u0165 priradi\u0165 tento oblek dan\u00e9mu policajtovi, teda sk\u00fa\u0161ame aj minim\u00e1lny.</li> </ol> <p>Memoiz\u00e1cia tohto pr\u00edkladu vy\u017eaduje vytvorenie tabu\u013eky ve\u013ekosti \\(|V| \\times |P|\\). Pre ka\u017ed\u00fd index \\(p, q\\)  si budeme pam\u00e4ta\u0165 minim\u00e1lnu nespokojnos\u0165 ak prirad\u00edme \\(p\\)-t\u00e9mu policajtovi prevlek \\(q\\). V ka\u017edom rekurz\u00edvnom volan\u00ed sa op\u00e4\u0165 vol\u00e1 kon\u0161tantn\u00fd po\u010det oper\u00e1ci\u00ed, op\u00e4\u0165 teda \u010dasov\u00e1 zlo\u017eitos\u0165 \\(\\mathcal{O}(|V| \\times |P|) = \\mathcal{O}(n^2)\\).</p> <p> Vraca\u0165 prevleky by bolo v rekurz\u00edvnom rie\u0161en\u00ed asi treba tak, \u017ee si postupne prebubleme rekurz\u00edvnymi volaniami nejak\u00e9 pole, do ktor\u00e9ho si pou\u017eit\u00e9 prevleky zapisujeme. V iterat\u00edvnom rie\u0161en\u00ed by to v\u0161ak i\u0161lo jednoduch\u0161ie, a mysl\u00edm si, \u017ee aspo\u0148 my\u0161lienka je zauj\u00edmav\u00e1. Tabu\u013eku by sme mohli napr\u00edklad vyp\u013a\u0148a\u0165 od posledn\u00e9ho policajta a prevleku, a v poslednom st\u013apci memoiza\u010dnej tabu\u013eky budeme teda ma\u0165 n\u00e1padnos\u0165 posledn\u00e9ho policajta \\(p\\), ak mu prirad\u00edme prevlek \\(q\\). Pre \u010fa\u013e\u0161ieho policajta odzadu minimalizujeme teda jeho vlastn\u00fa n\u00e1padnos\u0165 pre prevlek \\(q\\) + minim\u00e1lnu n\u00e1padnos\u0165 \u010fal\u0161ieho policajta, ktor\u00fd si vyber\u00e1 z prevlekov \\(q + 1\\) a\u017e \\(|P|\\). Pre predstavu for loop:</p> <pre><code>for p = Policajti.length ... 0:\n    for q = Prevleky.length ... 0:\n        if p == Policajti.length: memo[p][q] = vypocitaj napadnost policajta Policajt[p] s prevlekom Prevlek[q]\n        min_napadnost_dalsieho = inf\n        for k = q + 1 ... Prevleky.length # dalsiemu policajtovi mozeme priradit az q + 1. prevlek\n            min_napadnost_dalsieho = min(min_napadnost_dalsieho, memo[p][k])\n        memo[p][q] = vypocitaj napadnost policajta Policajt[p] s prevlekom Prevlek[q] \n                        + min_napadnost_dalsieho\n</code></pre> <p>Tu by sme si v zvl\u00e1\u0161\u0165 v tabulke ukladali, ak\u00fd prevlek sme prira\u010fovali \u010fal\u0161iemu policajtovi (teda niekam by sme ukladali e\u0161te index k). Tak by sme mohli sp\u00e4tne zostavi\u0165 kombin\u00e1cie policajt-prevlek.</p>"},{"location":"00_Testy/DP_%C3%BAlohy/#implication-dp.5","title":"Kabely","text":"\u0158e\u0161en\u00ed <p>Form\u00e1lne sa probl\u00e9m p\u00fdta na to, ako dok\u00e1\u017eeme za \u010do najlacnej\u0161iu cenu vyplni\u0165 vrcholy v strome tak, \u017ee \u017eiadne susedn\u00e9 konektory nie s\u00fa rovnak\u00e9ho typu. </p> <p> Pozrime sa na probl\u00e9m trochu z\u00fa\u017eene. Majme nejak\u00fd vrchol \\(V\\), a prira\u010fme mu konektor \\(A\\), a teda cenu uzla s konektorom \\(A\\). Ignorujme teraz na chv\u00ed\u013eu vrchol \\(V\\). Ten bol spojen\u00fd s vrcholmi \\(U_1, U_2, ... U_d\\) kde \\(d = deg(V)\\). Vpodstate sme ale takto vytvorili \\(d\\) postromov smeruj\u00facich pre\u010d od \\(v\\), na ktor\u00fdch m\u00f4\u017eeme rie\u0161i\u0165 rovnak\u00fd probl\u00e9m (teda h\u013eadanie sady uzlov s najmen\u0161ou cenou), iba s podmienkou, \u017ee  \\(konektor(U_1), konektor(U_2), ... konektor(U_d) \\ne A\\). Rie\u0161ime teda rovnak\u00fd probl\u00e9m, ale u\u017e nie pre vrchol \\(V\\), ale pre \\(U_1, U_2, ... U_d\\). Celkov\u00e1 cena bude potom </p> \\[cena_A + cenapodstromu(U_1) + cenapodstromu(U_2) + ... + cenapodstromu(U_d)\\] <p> Samozrejme je mo\u017en\u00e9, \u017ee v\u00fdberom konektoru \\(A\\) sme sa cenovo zle obmedzili, a keby vyberieme napr\u00edklad konektor \\(B\\), tak dostaneme men\u0161iu cenu. H\u013ead\u00e1me teda op\u00e4\u0165 minimum cez v\u0161etky konektory, ktor\u00e9 m\u00f4\u017eeme vrcholu \\(V\\) priradi\u0165.</p> <pre><code>s := strom, v tomto pripade ho pre jednoduchost reprezentujem tak, ze s[v] vrati susedov v\nk := pole konektorov\nc := ceny konektorov, c[k] je cena konektoru k\n# Predchodca je vrchol, z ktoreho volame toto rekurzivne volanie\n# Tomuto vrcholu sme uz priradili konektor, nechceme sa do neho vracat\n# Obmedzenie je typ konektoru, ktory sme pouzili na predchodcovi, ten teda nemozme priradit sebe\n# funkcia vracia zoznam priradeni konektorov vrcholom v podstrome, ktory teraz skumame\ncena_podstromu(vrchol, obmedzenie, predchodca):\n    # ak je vrchol list, prirad mu najlacnejsi mozny konektor\n    if s[vrchol] = [predchodca]: \n        if c.najlacnejsi != obmedzenie: return [vrchol: c.najlacnejsi]\n        else return [vrchol: c.druhy_najlacnejsi]\n\n    min_cena = inf\n    min_konektor = undef\n    min_konektory_ostatnych = []\n    for konektor in {k - obmedzenie}: # skusme dat nasmu vrcholu vsetky konektory, okrem obmedzenia\n        celkova_cena_v_pre_konektor_k = c[konektor]\n        konektory_susedov = []\n        for sused in {vrchol.susedia - predchodca}: # nechceme volat rekurziu pre predchodcu\n            zavolaj cena_podstromu(sused, konektor, vrchol)\n            cenu pre podstrom od suseda pripocitaj do celkova_cena_v_pre_konektor_k\n            # podstromy su disjunktne\n            konektory_susedov.append(vratene pole konektorov z riadku 21) \n\n        if celkova_cena_v_pre_konektor_k &lt; min_cena:\n            min_cena = celkova_cena_v_pre_konektor_k\n            min_konektor = konektor\n            min_konektory_ostatnych = konektory_susedov\n\n    return min_konektory_ostatnych + [vrchol: min_konektor]\n</code></pre> <p>T\u00fato funkciu m\u00f4\u017eeme n\u00e1sledne zavola\u0165 na \u013eubovo\u013en\u00fd vrchol s obmedzen\u00edm nastaven\u00fdm na undefined. Tu by sa mo\u017eno zi\u0161iel nejak\u00fd d\u00f4kaz, ja by som ale jednoducho povedal, \u017ee t\u00e1to rekurzia sk\u00fasi v\u0161etky mo\u017en\u00e9 kombin\u00e1cie, a teda aj t\u00fa optim\u00e1lnu.</p> <p> Ke\u010f u\u017e sa rozpr\u00e1vame o optim\u00e1lnosti, asi by sa oplatilo pou\u017e\u00ed\u0165 nejak\u00fa memoiz\u00e1ciu. Memoiza\u010dn\u00e1 tabu\u013eka bude ma\u0165 teraz 2 rozmery, jeden bud\u00fa vrcholy, a druh\u00fd bud\u00fa konektory. Do tabu\u013eky si ulo\u017e\u00edme, ak\u00e1 je minim\u00e1lna cena podstromu od dan\u00e9ho vrcholu, ak m\u00e1 vrchol obmedzenie na dan\u00fd konektor. </p> <p> Tu je asi d\u00f4le\u017eit\u00e9 zmieni\u0165, \u017ee pri volan\u00ed funkcie <code>cena_podstromu</code> na nejak\u00fd vrchol \\(v\\) bude v\u017edy <code>predchodca</code> rovnak\u00fd. Pre\u010do? No medzi na\u0161\u00edm po\u010diato\u010dn\u00fdm vrcholom a vrcholom \\(v\\) m\u00f4\u017ee existova\u0165 iba jedna cesta (graf je strom), a teda predchodca na tejto ceste bude v\u017edy rovnak\u00fd. Memoiza\u010dn\u00e1 tabu\u013eka bude ale vyzera\u0165 r\u00f4zne pod\u013ea toho, z ak\u00e9ho vrcholu za\u010dneme.</p> <p> \u010casov\u00e1 zlo\u017eitos\u0165 je tu ajtak trochu hor\u0161ia, pre ka\u017ed\u00e9 pol\u00ed\u010dko v memoiza\u010dnej tabu\u013eke toti\u017e vykon\u00e1vame \\(k \\cdot deg(v)\\) oper\u00e1ci\u00ed, r\u00e1dovo \\(\\mathcal{O}(k\\cdot V(T))\\). Vzh\u013eadom na ve\u013ekos\u0165 tabu\u013eky dost\u00e1vame celkov\u00fa \u010dasov\u00fa zlo\u017eitos\u0165 \\(\\mathcal{O}(k^2\\cdot V(T)^2)\\)</p> <p> E\u0161te jedna vec, nemus\u00edme si v memoiza\u010dnej tabu\u013eke pred\u00e1va\u0165 cel\u00fd zoznam konektorov. Ak sa nad t\u00fdm zamysl\u00edme, pre ka\u017ed\u00fd vrchol si mus\u00edme iba pam\u00e4ta\u0165, ak\u00fd typ konektoru mu priradi\u0165, pre ka\u017ed\u00e9 obmedzenie, a z\u00e1rove\u0148 cenu podstromu pri takomto obmedzen\u00ed. Pri rekon\u0161trukci\u00ed rie\u0161enia si pre inici\u00e1lny vrchol \\(V\\) teda vyberieme konektor, ktor\u00fd vedie k najmen\u0161ej cene (najmen\u0161ie \u010d\u00edslo v st\u013apci vrcholu \\(v\\)), a potom rekurz\u00edvne sa v tabu\u013eke pozrieme na st\u013apce v\u0161etk\u00fdch susedn\u00fdch vrcholov, sp\u00fdtame sa, ak\u00e1 je ich hodnota pri tomto obmedzen\u00ed, a ak\u00fd konektor pre tento vrchol vybra\u0165 (toto, ako som spomenul, uklad\u00e1me tie\u017e do tabu\u013eky), \u010do n\u00e1m dovol\u00ed sa rekurz\u00edvne pozrie\u0165 na jeho susedov a spravi\u0165 to ist\u00e9.</p>"},{"location":"00_Testy/Finty/","title":"Finty","text":"<p>Fintov\u00fd znalec doc. Dr. rer. nat. Ing. Jan Valdman</p>"},{"location":"00_Testy/Finty/#rozstrel","title":"Rozst\u0159el","text":"<p>\u00daloha na z\u00e1porn\u00fd cyklus</p> <p>Uva\u017eujeme existenci n\u011bjak\u00e9 cesty</p> <ol> <li> <p>Neexistuje z\u00e1porn\u00fd cyklus</p> <ul> <li>existuje nejkrat\u0161\u00ed cesta</li> <li>existuje nejkrat\u0161\u00ed sled (je stejn\u00fd jako nejkrat\u0161\u00ed cesta)</li> </ul> </li> <li> <p>Existuje z\u00e1porn\u00fd cyklus</p> <ul> <li>existuje nejkrat\u0161\u00ed cesta</li> <li>neexistuje nejkrat\u0161\u00ed sled</li> </ul> </li> </ol>"},{"location":"00_Testy/Zkou%C5%A1ka/","title":"Zkou\u0161ka","text":""},{"location":"00_Testy/Zkou%C5%A1ka/#stromy","title":"Stromy","text":"<p>Teorie</p> <ul> <li>Definujte strom. (1b)</li> <li>Formulujte vetu o existenci listu a dok\u00e1\u017ete. (3b)</li> <li>Formulujte vetu o trhani listu a dok\u00e1\u017ete. (3b)</li> <li>Formulujte nejakou ekvivalentni defin\u00edci stromu a dok\u00e1\u017ete, \u017ee t\u00e1to ekvivalence plat\u00ed. (3b)</li> </ul>"},{"location":"00_Testy/Zkou%C5%A1ka/#bfs","title":"BFS","text":"<p>Teorie</p> <ul> <li>Napi\u0161te algoritmus BFS bu\u010f podrobn\u011b slovn\u011b nebo komentovan\u00fdm pseudok\u00f3dem a popi\u0161te co znamenaj\u00ed pou\u017e\u00edvan\u00e1 pomocn\u00e1 pole P a D. (3b)</li> <li>Doka\u017ete spr\u00e1vnost algoritmu BFS, \u017ee BFS uzav\u0159e jen dosa\u017eiteln\u00e9 vrcholy ze startovn\u00edho vrcholu s. (2b)</li> </ul> <p></p> <p>\u00daloha - Jones a Obluda</p> <p></p> <p>\u00daloha - Tajn\u00fd agent</p>"},{"location":"00_Testy/Zkou%C5%A1ka/#implication-bfs.1","title":"\u00daloha - Jones a Obluda","text":"<p>Na vstupu matice, kde jednotliv\u00e9 pole reprezentovaly voln\u00fd prostor nebo st\u011bnu. V bludi\u0161ti je Indiana Jones a obluda. Indiana se pohybuje ka\u017ed\u00e9 kolo jen o jedno pol\u00ed\u010dko (nemus\u00ed se ale pohybovat v\u016fbec). Obluda se pohybuje o dv\u011b pol\u00ed\u010dka, pohybuje se ale deterministicky. V\u017edy se pokus\u00ed zmen\u0161it svoji vzd\u00e1lenost od Indiany (bu\u010f zmen\u0161it sou\u0159adnici x a nebo y, s t\u00edm, \u017ee prioritn\u011b zmen\u0161uje X). V moment\u011b, co se obluda \u017e\u00e1dn\u00fdm krokem nem\u016f\u017ee p\u0159ibl\u00ed\u017eit, neh\u00fdbe se (mezi Indianou a obludou je st\u011bna). \u00dakolem je vymyslet algoritmus, kter\u00fd nalezne nejrakt\u0161\u00ed sled ze Startu do c\u00edle bez setk\u00e1n\u00ed se s obludou (5b)</p> \u0159e\u0161en\u00ed <p>Jeliko\u017e je obluda deterministick\u00e1, m\u016f\u017eeme si vytvo\u0159it graf, kde ka\u017ed\u00fd vrchol bude reprezentovat pozici Jonese a obludy. Hrany budou reprezentovat pohyb Jonese. N\u00e1sledn\u011b m\u016f\u017eeme pou\u017e\u00edt BFS, kde v ka\u017ed\u00e9m kroku zjist\u00edme, zda se obluda m\u016f\u017ee p\u0159ibl\u00ed\u017eit Jonese. Pokud ano, tak dan\u00fd vrchol ignorujeme. Pokud ne, tak se pohybujeme d\u00e1l. Pokud se dostaneme do c\u00edle, tak jsme na\u0161li nejkrat\u0161\u00ed cestu. </p> <p>(AI Written - not reviewed)</p>"},{"location":"00_Testy/Zkou%C5%A1ka/#implication-bfs.2","title":"\u00daloha - Tajn\u00fd agent","text":"<p>M\u00e1me tajnou operaci, tajn\u00fd agent m\u00e1 dopadnout na p\u0159esn\u011b stanoven\u00fd d\u016fm a p\u0159ej\u00edt do jin\u00e9ho domu bu\u010f sk\u00e1k\u00e1n\u00edm po st\u0159ech\u00e1ch nebo chozen\u00edm p\u0159es sklep. Zm\u011bna toho jestli jde po st\u0159e\u0161e nebo p\u0159es sklep m\u016f\u017ee nastat v ka\u017ed\u00e9m dom\u011b ale stoj\u00ed to agenta v\u00edce \u010dasu (a m\u016f\u017ee b\u00fdt odhalen), proto po\u010det zm\u011bn chceme minimalizovat. Uva\u017eujeme, \u017ee z jednoho domu do druh\u00e9ho m\u016f\u017ee j\u00edt pouze jedn\u00edm typem hrany (tedy ne st\u0159echou i sklepem). Hrany jsou tedy ozna\u010deny nap\u0159. pomoc\u00ed roof (st\u0159echa) nebo base (sklep). Najd\u011bte co nejkrat\u0161\u00ed cestu ze za\u010d\u00ednaj\u00edc\u00edho domu s do domu d tak, aby algoritmus po\u010d\u00edtal po\u010det zm\u011bn roof/base, tzn. kolikr\u00e1t agent musel p\u0159ej\u00edt p\u0159es d\u016fm a toto \u010d\u00edslo minimalizoval. Chceme tak\u00e9 aby \u0161lo o nejkrat\u0161\u00ed z mo\u017en\u00fdch takov\u00fdch cest. Slo\u017eitost algoritmu by m\u011bla b\u00fdt O(|V|+|E|). Za O(|V|\u00b2) max 2b.</p> <p>N\u00e1pov\u011bda: m\u016f\u017eete nap\u0159\u00edklad vhodn\u011b modifikovat algoritmus BFS (nebo upravit vhodn\u011b graf). (5b)</p> N\u00e1znak \u0159e\u0161en\u00ed <p>( Mo\u017en\u00e1 spr\u00e1vn\u011b, feel free to correct )</p> <ul> <li>Vytvo\u0159\u00edme graf, kde ka\u017ed\u00fd vrchol bude reprezentovat stav agenta (pozice, zda je na st\u0159e\u0161e nebo v suter\u00e9nu). Hrany budou reprezentovat pohyb agenta mezi domy a p\u0159echodov\u00e9 hrany mezi st\u0159echou a suter\u00e9nem.</li> <li>\u00daprava BFS na dv\u011b fronty, kde jedna zna\u010d\u00ed pohyb v dan\u00e9 hladin\u011b a druh\u00e1 zna\u010d\u00ed p\u0159echod mezi st\u0159echou a suter\u00e9nem.<ul> <li>Pokud prvn\u00ed frontu vy\u010derp\u00e1me, incrementujeme po\u010det p\u0159echod\u016f a p\u0159esypeme druhou frontu do prvn\u00ed.</li> </ul> </li> <li>Ukon\u010d\u00edme pokud jsme v c\u00edlov\u00e9m dom\u011b (bu\u010f v suter\u00e9nu nebo na st\u0159e\u0161e).</li> </ul>"},{"location":"00_Testy/Zkou%C5%A1ka/#topologicke-usporadani","title":"Topologick\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed","text":"<p>Teorie</p> <ul> <li>Definujte topologick\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed vrchol\u016f orientovan\u00e9ho grafu. 1 bod</li> <li>Formulujte a doka\u017ete V\u011btu o existenci zdroje orientovan\u00e9ho grafu. \u2014 3 body</li> <li>Slovn\u011b \u010di komentovan\u00fdm pseudok\u00f3dem popi\u0161te algoritmus TopSort v\u010detn\u011b pou\u017e\u00edvan\u00fdch datov\u00fdch struktur, p\u0159\u00edpadn\u011b nejd\u016fle\u017eit\u011bj\u0161\u00ed \u010d\u00e1sti popi\u0161te pseudok\u00f3dem. 3 body</li> <li>Doka\u017ete jeho spr\u00e1vnost, tedy \u017ee v kone\u010dn\u00e9m \u010dase vyd\u00e1 po\u017eadovan\u00fd v\u00fdsledek. 3 body</li> </ul> <p></p> <p>\u00daloha - Antick\u00e1 civilizace</p>"},{"location":"00_Testy/Zkou%C5%A1ka/#implication-topo.1","title":"\u00daloha - Antick\u00e1 civilizace","text":"<ul> <li>M\u00e1me k dispozici str\u00e1nku ze slovn\u00edku antick\u00e9 civilizace - pou\u017e\u00edvaj\u00ed podmno\u017einu na\u0161\u00ed abecedy {A, B, \u2026, Z}, ale v jin\u00e9m po\u0159ad\u00ed. V\u00edme, \u017ee slova na t\u00e9to str\u00e1nce jsou v lexikografick\u00e9m uspo\u0159\u00e1d\u00e1n\u00ed.</li> <li>Navrhn\u011bte algoritmus, kter\u00fd z posloupnosti slov (s_1, s_2, \u2026, s_k) sestav\u00ed uspo\u0159\u00e1d\u00e1n\u00ed jednotliv\u00fdch pou\u017eit\u00fdch znak\u016f. </li> <li>Algoritmus tak\u00e9 mus\u00ed detekovat p\u0159\u00edpady, kdy je uspo\u0159\u00e1d\u00e1n\u00ed z dostupn\u00fdch slov nejednozna\u010dn\u00e9, nebo kdy slova nedodr\u017euj\u00ed lexikografick\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed. </li> <li>Doka\u017ete korektnost tohoto algoritmu, \u010dasovou a pam\u011b\u0165ovou slo\u017eitost vzta\u017eenou k hodnot\u00e1m k (po\u010det slov) a n (suma d\u00e9lek slov). (5b)</li> </ul>"},{"location":"00_Testy/Zkou%C5%A1ka/#haldy","title":"Haldy","text":"<p>Bin\u00e1rn\u00ed halda</p> <p></p> <p>Binomi\u00e1ln\u00ed halda</p>"},{"location":"00_Testy/Zkou%C5%A1ka/#theorem-bin_heap","title":"Bin\u00e1rn\u00ed halda","text":"<ul> <li>Definujte bin\u00e1rn\u00ed haldu (1 bod)</li> <li>Popi\u0161te operace HeapInsert a HeapExtractmin a doka\u017ete jejich \u010dasovou slo\u017eitost (5 bod\u016f)</li> <li>Popi\u0161te HeapBuild (2 body)</li> <li>Doka\u017ete \u010dasovou slo\u017eitost HeapBuild (3 body)</li> </ul>"},{"location":"00_Testy/Zkou%C5%A1ka/#theorem-binomial_heap","title":"Binomi\u00e1ln\u00ed halda","text":"<ul> <li>Definujte binomi\u00e1ln\u00ed strom \u0159\u00e1du k. (1b)</li> <li>Uka\u017ete, kolik m\u00e1 binomi\u00e1ln\u00ed strom \u0159\u00e1du k vrchol\u016f, jak\u00e1 je jeho hloubka a jak\u00fd je stupe\u0148 ko\u0159ene. (3b)</li> <li>Popi\u0161te operaci BHMerge(), doka\u017ete jej\u00ed korektnost a \u010dasovou slo\u017eitost. (4b)</li> <li>Popi\u0161te operaci BHExtractMin(), doka\u017ete jej\u00ed \u010dasovou slo\u017eitost (2b)</li> </ul>"},{"location":"00_Testy/Zkou%C5%A1ka/#rozdel-a-panuj","title":"Rozd\u011bl a panuj","text":""},{"location":"00_Testy/Zkou%C5%A1ka/#mergesort","title":"MergeSort","text":"<p>MergeSort</p> <ul> <li>Podrobn\u011b slovn\u011b i pseudok\u00f3dem popi\u0161te algoritmus MergeSort. </li> <li>Zd\u016fvodn\u011bte jeho spr\u00e1vnost a odvo\u010fdte jeho \u010dasovou a pam\u011b\u0165ovou slo\u017eitost.</li> </ul> <p></p> <p>\u00daloha - Vz\u00e1cn\u00e9 prvky</p>"},{"location":"00_Testy/Zkou%C5%A1ka/#implication-merge.1","title":"\u00daloha - Vz\u00e1cn\u00e9 prvky","text":"<ul> <li>Dostali jsme n\u00e1dobu plnou kuli\u010dek \u2014 ozna\u010dme jejich po\u010det M. V\u0161echny kuli\u010dky jsou podle tvaru, v\u00e1hy, chuti, v\u016fn\u011b i dal\u0161\u00edch, lidsk\u00fdmi smysly testovateln\u00fdch vlastnost\u00ed nerozli\u0161iteln\u00e9 jedna od druh\u00e9. Kuli\u010dky maj\u00ed ve sv\u00e9m j\u00e1dru uzav\u0159en\u00fd jeden atom vz\u00e1cn\u00e9ho prvku. M\u00e1me k dispozici za\u0159\u00edzen\u00ed, kter\u00e9, pokud na vstup dostane dv\u011b kuli\u010dky, sv\u00edt\u00ed \u010derven\u011b (v p\u0159\u00edpad\u011b, \u017ee jsou v j\u00e1drech testovan\u00fdch kuli\u010dek r\u016fzn\u00e9 atomy vz\u00e1cn\u00fdch prvk\u016f) a nebo zelen\u011b (jsou-li v j\u00e1drech testovan\u00fdch kuli\u010dek shodn\u00e9 atomy vz\u00e1cn\u00fdch prvk\u016f). </li> <li>Va\u0161\u00edm \u00fakolem je navrhnout algoritmus, kter\u00fd zjist\u00ed, zda existuje vz\u00e1cn\u00fd prvek, kter\u00fd je obsa\u017een ve striktn\u011b v\u00edce ne\u017e N/2 kuli\u010dk\u00e1ch. V\u00e1\u0161 algoritmus mus\u00ed pracovat v \u010dase o(N?). Algoritmus podrobn\u011b slovn\u011b popi\u0161te, p\u0159\u00edpadn\u011b nejd\u016fle\u017eit\u011bj\u0161\u00ed \u010d\u00e1sti zapi\u0161te v pseudokddu. Zd\u016fvodn\u011bte spr\u00e1vnost va\u0161eho algoritmu. Odvo\u010fdte \u010dasovou a pam\u011b\u0165ovou slo\u017eitost. va\u0161eho \u0159e\u0161en\u00ed. e N\u00e1pov\u011bda: Vhodn\u011b modifikujte algoritmus MergeSort.</li> </ul> N\u00e1znak \u0159e\u0161en\u00ed <ul> <li>Upraven\u00ed MergeSortu tak, aby vracel jen bu\u010f kandid\u00e1ta na vz\u00e1cn\u00fd prvek, nebo Fail indik\u00e1tor. Pokud spojuji:<ol> <li>Prvek a prvek -&gt; Pokud jsou stejn\u00e9, tak vrac\u00edm prvek, pokud ne, tak Fail</li> <li>Prvek a Fail -&gt; Pot\u0159eba spo\u010d\u00edtat po\u010det prvk\u016f, kter\u00e9 jsou stejn\u00e9 jako prvek v pat\u0159i\u010dn\u00e9 \u010d\u00e1sti pole</li> <li>Fail a Fail -&gt; Fail</li> </ol> </li> </ul>"},{"location":"00_Testy/Zkou%C5%A1ka/#quickselect","title":"QuickSelect","text":"<p>Teorie</p> <ul> <li>Napi\u0161te pseudok\u00f3d algoritmu QuickSelect a popi\u0161te ho.</li> <li>Doka\u017ete slo\u017eitost algoritmu v nejhor\u0161\u00edm p\u0159\u00edpad\u011b.</li> <li>Doka\u017ete slo\u017eitost algoritmu v p\u0159\u00edpad\u011b, \u017ee jako pivota vol\u00edme poka\u017ed\u00e9 skoromedi\u00e1n.</li> <li>Uka\u017ete a d\u016fkladn\u011b doka\u017ete slo\u017eitost algoritmu ve st\u0159edn\u00ed hodnot\u011b s n\u00e1hodnou volbou pivota.</li> </ul>"},{"location":"00_Testy/Zkou%C5%A1ka/#karatsubovo-nasobeni","title":"Karatsubovo n\u00e1soben\u00ed","text":"<p>Teorie</p> <ul> <li>Popi\u0161te Karatsubovo n\u00e1soben\u00ed</li> </ul>"},{"location":"00_Testy/Zkou%C5%A1ka/#minimalni-kostry","title":"Minim\u00e1ln\u00ed kostry","text":"<p>Teorie</p> <ul> <li>Definujte kostru, probl\u00e9m hled\u00e1n\u00ed minim\u00e1ln\u00ed kostry a Kruskal\u016fv algoritmus (nen\u00ed pot\u0159eba popisovat vylep\u0161ovac\u00ed struktury jen hlavn\u00ed my\u0161lenku) ( 2 body)</li> <li>Popi\u0161te lemma o \u0159ezech a doka\u017ete ho. (3 body)</li> <li>Definice Element\u00e1rn\u00edho \u0159ezu</li> <li>Jarn\u00edk\u016fv algoritmus</li> <li>Definujte strukturu Union-Find s ke\u0159\u00edkovou implementac\u00ed (2b)</li> <li>Doka\u017ete, \u017ee \u010dasov\u00e9 slo\u017eitosti Union a Find jsou O(log n) (3b)</li> </ul> <p></p> <p>\u00daloha - M\u011bsta a ar\u00e9ny (5b)</p> <p></p> <p>\u00daloha - UF - Add a Increase</p>"},{"location":"00_Testy/Zkou%C5%A1ka/#implication-mst.1","title":"\u00daloha - M\u011bsta a ar\u00e9ny","text":"<ul> <li>\u00dakol na \u00fapravu Kruskala - M\u00e1me dan\u00e9 ceny silnic mezi r\u016fzn\u00fdmi m\u011bsty a ceny ar\u00e9n. M\u016f\u017eeme v libovoln\u00e9m m\u011bst\u011b postavit ar\u00e9nu pop\u0159\u00edpad\u011b spojit dv\u011b m\u011bsta cestou. Jak nejlevn\u011bji za\u0159\u00eddit, aby se z ka\u017ed\u00e9ho m\u011bsta lid\u00e9 dostali do ar\u00e9ny? M\u016f\u017eou nastat extr\u00e9mn\u00ed p\u0159\u00edpady:<ul> <li>V ka\u017ed\u00e9m m\u011bst\u011b zvl\u00e1\u0161\u0165 postav\u00edme ar\u00e9nu</li> <li>Postav\u00edme ar\u00e9nu v jednom m\u011bst\u011b a spoj\u00edme toto m\u011bsto se v\u0161emi ostatn\u00edmi cestami.</li> </ul> </li> </ul> \u0158e\u0161en\u00ed <ul> <li>Sestroj\u00edme graf kde vrcholy jsou m\u011bsta a jedna \"super ar\u00e9na\"</li> <li>Ohodnocen\u00e9 hrany mezi m\u011bsty zn\u00e1zor\u0148uj\u00ed cenu cesty mezi nimi, zat\u00edmco ohodnocen\u00e9 hrany mezi ka\u017ed\u00fdm m\u011bstem a super ar\u00e9nou zn\u00e1zor\u0148uj\u00ed cenu vystaven\u00ed ar\u00e9ny v dan\u00e9m m\u011bst\u011b</li> <li>Po projet\u00ed tohoto grafu kruskalem zbydou ty hrany mezi m\u011bsty kde se v\u00edce vyplat\u00ed postavit cesta a tam kde zbyde hrana mezi m\u011bstem a super ar\u00e9nou se vyplat\u00ed postavit ar\u00e9nu</li> <li>Korektnost tohoto faktu nech\u00e1v\u00e1me bez d\u016fkazu</li> </ul>"},{"location":"00_Testy/Zkou%C5%A1ka/#implication-uf.1","title":"\u00daloha - UF - Add a Increase","text":"<p>M\u011bjme zadan\u00e9 vrcholy, kter\u00e9 maj\u00ed ka\u017ed\u00fd p\u0159i\u0159azenou hodnotu (cenu) a kter\u00e9 nejsou ze za\u010d\u00e1tku propojeny. Navrhn\u011bte takovou strukturu, kter\u00e1 bude podporovat operace: - Add(v,w) - propoj\u00ed vrchol v a w hranou (pokud je\u0161t\u011b nejsou). - Increase(v,x) - zv\u00fd\u0161\u00ed vrcholu v cenu o konstantu x.</p> <p>Po ka\u017ed\u00e9m proveden\u00ed operace Add nebo Increase vra\u0165te v\u0161echny hrany dan\u00e9 komponenty. Tyto dv\u011b operace mus\u00ed fungovat v logaritmick\u00e9m \u010dase, z\u00e1rove\u0148 doka\u017ete \u017ee opravdu v log n \u010dase pracuj\u00ed. Byl tam tip, \u017ee m\u00e1me vhodn\u011b upravit strukturu union find. (5b) </p>"},{"location":"00_Testy/Zkou%C5%A1ka/#quick-sort-problem-razeni","title":"Quick Sort (+ Probl\u00e9m \u0159azen\u00ed)","text":"<p>Teorie</p> <ul> <li>Definujte porovn\u00e1vac\u00ed model \u0159azen\u00ed. 1 bod</li> <li>Formulujte a doka\u017ete V\u011btu o doln\u00edm odhadu slo\u017eitosti \u0159azen\u00ed. 4 body</li> <li>Definujte probl\u00e9m \u0159azen\u00ed cel\u00fdch \u010d\u00edsel. </li> <li>Formulujte a doka\u017ete v\u011btu o slo\u017eitosti vyhled\u00e1v\u00e1n\u00ed v se\u0159azen\u00e9 posloupnosti. </li> <li>Formulujte v\u011btu o slo\u017eitosti \u0159azen\u00ed.</li> <li>Komentovan\u00fdm pseudok\u00f3dem popi\u0161te algoritmus CountingSort.</li> <li>Popi\u0161te, kterou \u010d\u00e1st algoritmu CountingSort nelze v porovn\u00e1vac\u00edm modelu RAM prov\u00e9st a pro\u010d.</li> </ul> <p></p> <p>\u00daloha vyvra\u0165 insert a medi\u00e1n v O(1)</p> <p>Jist\u00fd Ondra S. tvrd\u00ed, \u017ee pro \u00fa\u010dely druh\u00e9 progtestov\u00e9 \u00falohy z BI-AG1 vymyslel n\u00e1sleduj\u00edc\u00ed datovou strukturu na ukl\u00e1d\u00e1n\u00ed libovoln\u00fdch prvk\u016f, kter\u00e9 um\u00edme mezi sebou pouze porovn\u00e1vat. Tato struktura podporuje</p> <ul> <li>operace Insert (vlo\u017e\u00ed prvek do struktury) a.</li> <li>zvl\u00e1\u0161tn\u00ed funkci ExtractMedian (vr\u00e1t\u00ed a ze struktury vyma\u017ee takov\u00fd prvek, kter\u00fd je medi\u00e1nem aktu\u00e1ln\u011b ulo\u017een\u00fdch dat),</li> </ul> <p>oboj\u00ed pr\u00fd v \u010dase O(1) worst-case.</p> <p>Doka\u017ete, \u017ee se Ondra m\u00fdl\u00ed, proto\u017ee \u017e\u00e1dn\u00e1 takov\u00e1 datov\u00e1 struktura nem\u016f\u017ee existovat! Dejte si z\u00e1le\u017eet, a\u0165 je v\u00e1\u0161 d\u016fkaz podrobn\u00fd a m\u00e1 v\u0161echny n\u00e1le\u017eitosti. 5 bod\u016f N\u00e1pov\u011bda: Aplikujte v\u011btu o doln\u00edm odhadu slo\u017eitosti \u0159azen\u00ed.</p>"},{"location":"00_Testy/Zkou%C5%A1ka/#orientovane-grafy","title":"Orientovan\u00e9 grafy","text":"<p>Teorie</p> <ul> <li>Definice sledu a velikosti sledu. (1b)</li> <li>Definice troj\u00faheln\u00edkov\u00e9 nerovnosti a jej\u00ed d\u016fkaz. (2b)</li> <li>Napi\u0161te pseudok\u00f3d algoritmu Relaxace a popi\u0161te ho. (4b)</li> <li>Dok\u00e1zat vlastnost (V) Vzd\u00e1lenosti algoritmu Relaxace (3b)</li> </ul>"},{"location":"00_Testy/Z%C3%A1po%C4%8Det/","title":"Z\u00e1po\u010det","text":"<p>Graf G s pr\u016fm\u011brn\u00fdm stupn\u011bm \\(\\alpha\\)</p> <p>Michal dvo\u0159\u00e1k, cv1</p> <p>Cvi\u010den\u00ed 1.5</p> <p>Zad\u00e1n\u00ed: Ur\u010dete po\u010det v\u0161ech indukovan\u00fdch podgraf\u016f grafu \\(K_{n}\\)</p> <p>\u0158e\u0161en\u00ed: </p> <ul> <li>Sou\u010det v\u0161ech \\(K_{l}\\) kde \\(l \\in \\{1,...,n\\}\\) </li> </ul> \\[ \\sum_{i=1}^{n}\\binom{n}{i} = 2^{n} -1 \\] <p>Cvi\u010den\u00ed 1.10</p> <p>Zad\u00e1n\u00ed: Graf, kter\u00fd obsahuje kru\u017enici jako podgraf, obsahuje kru\u017enici jako indukovan\u00fd podgraf</p> <p>\u0158e\u0161en\u00ed:</p> <ul> <li>Pokud je i indukovan\u00fd podgraf kru\u017enice, tak finished</li> <li>Jinak rozd\u011blit podle t\u011btivy a vz\u00edt men\u0161\u00ed \u010d\u00e1st \\(\\rightarrow\\) rekurze</li> <li>1.10.2 neplat\u00ed \\(\\rightarrow\\) proti p\u0159\u00edklad nap\u0159. \\(K_{n}\\)</li> <li>1.10.3 pla\u00ed \\(\\rightarrow\\) lich\u00e1 se podle t\u011btivy rozd\u011bl\u00ed v\u017edy na sudou a lichou \u010d\u00e1st \\(\\rightarrow\\) rekurze do lich\u00e9</li> </ul>"},{"location":"00_Testy/Z%C3%A1po%C4%8Det/#graf-g-s-prumernym-stupnem","title":"Graf G s pr\u016fm\u011brn\u00fdm stupn\u011bm","text":"<p>M\u011bjme graf \\(G\\), kde  \\(\\alpha = \\dfrac{\\displaystyle\\sum_{v \\in V(G)} deg_{G}(v)}{|V(G)|}\\)</p> <p>pot\u00e9 existuje indukovan\u00fd podgraf \\(H\\) takov\u00fd \u017ee \\((\\forall v \\in V(G))(deg_H(v) \\ge \\frac{\\alpha}2)\\)</p> <p></p> <ul> <li>V\u00fdsledn\u00fd graf \\(H\\) vytvo\u0159\u00edme postupnou \"destrukc\u00ed\" grafu \\(G\\)</li> <li>Za\u010denem tedy s \\(H = G\\)</li> <li>Postupn\u011b budeme z grafu \\(H\\) odeb\u00edrat ka\u017ed\u00fd vrchol \\(v \\in V(H)\\) takov\u00fd \u017ee \\(deg_{H}(v) \\lt \\dfrac{\\alpha}{2}\\)</li> <li>Takto tedy odebereme maxim\u00e1ln\u011b \\(n\\) vrchol\u016f, kde \\(n = |V(H)|\\)</li> <li>Pokud ka\u017ed\u00fd vrchol m\u011bl stupe\u0148 \\(\\lt \\frac{\\alpha}{2}\\), m\u011bly tedy dohromady maxim\u00e1ln\u011b \\(n \\cdot k\\) stup\u0148\u016f, kde \\(k \\lt \\frac{\\alpha}{2}\\) </li> <li>Pro p\u016fvodn\u00ed graf \\(H\\) platilo \\(\\displaystyle\\sum_{v \\in V(H)} deg_{H}(v) = n \\cdot \\alpha\\)</li> <li>Pot\u00e9 co ode\u010dteme stupn\u011b n\u00e1mi odebran\u00fdch vrchol\u016f \\(\\cdot 2\\) (v\u010detn\u011b sousedn\u00edch vrchol\u016f, kter\u00fdm jsme stupe\u0148 odebr\u00e1n\u00edm tak\u00e9 sn\u00ed\u017eili)</li> <li>Nutn\u011b plat\u00ed:</li> </ul> \\[ n\\alpha = 2n \\frac{\\alpha}2  \\gt 2nk \\] \\[ \\displaystyle\\sum_{v \\in V(H)} deg_{H}(v) - 2nk = n\\alpha - 2nk \\gt 0 \\] <ul> <li>Tedy m\u00e1me nepr\u00e1zdn\u00fd graf \\(H\\), kter\u00fd je indukovan\u00fd (plyne z konstrukce), nepr\u00e1zdn\u00fd a v\u0161echny jeho vrcholy maj\u00ed stupe\u0148 \\(\\ge \\frac{\\alpha}{2}\\)</li> </ul>"}]}